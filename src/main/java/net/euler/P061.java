package net.euler;

import com.google.common.collect.Lists;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;
import com.google.common.collect.TreeMultimap;
import org.apache.commons.lang3.tuple.Pair;

import java.util.List;

import static net.euler.MathUtils.log10;
import static net.euler.MathUtils.sqrt;

/**
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and
 * are generated by the following formulae:
 * <p/>
 * Triangle     P(3,n)=n(n+1)/2   1, 3, 6, 10, 15, ...
 * Square       P(4,n)=n^2        1, 4, 9, 16, 25, ...
 * Pentagonal   P(5,n)=n(3n-1)/2  1, 5, 12, 22, 35, ...
 * Hexagonal    P(6,n)=n(2n-1)    1, 6, 15, 28, 45, ...
 * Heptagonal   P(7,n)=n(5n-3)/2  1, 7, 18, 34, 55, ...
 * Octagonal    P(8,n)=n(3n-2)    1, 8, 21, 40, 65, ...
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 * <p/>
 * The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including
 * the last number with the first).  Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and
 * pentagonal (P(5,44)=2882), is represented by a different number in the set.  This is the only set of 4-digit numbers
 * with this property.
 * <p/>
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
 * triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 *
 * @author Kevin Crosby
 */
public class P061 {
  private static int size;
  private static SetMultimap<Integer, Long> table = TreeMultimap.create();

  private static long p(final int s, final long n) {
    return (n * n * (s - 2) - n * (s - 4)) / 2;
  }

  private static long invP(final int s, final long x) {
    return (sqrt(8 * (s - 2) * x + (s - 4) * (s - 4)) + (s - 4)) / (2 * (s - 2));
  }

  private static void populateMap() {
    for (int s = 3; s <= size + 2; s++) {
      long pMin = 1000, pMax = 9999;
      long nMin = invP(s, pMin) + 1, nMax = invP(s, pMax);
      for (long n = nMin; n <= nMax; n++) {
        long p = p(s, n);
        assert log10(p) + 1 == 4 : "Fix your formula!";
        table.put(s, p);
      }
    }
  }

  private static boolean canJoin(final long a, final long b) {
    return a != b && a % 100 == b / 100 && b % 100 / 10 != 0;
  }

  private static List<Pair<Integer, Long>> makeCycle() {
    int s = size + 2;
    for (long p : table.get(s)) {
      if (p % 100 / 10 == 0) continue;
      List<Integer> testKeys = Lists.newArrayList(s);
      List<Long> testCycle = Lists.newArrayList(p);
      Pair<List<Integer>, List<Long>> pair = makeCycle(testKeys, testCycle);
      if (!pair.getLeft().isEmpty()) {
        List<Pair<Integer, Long>> pairs = Lists.newArrayList();
        List<Integer> keys = pair.getLeft();
        List<Long> cycle = pair.getRight();
        for (int i = 0; i < size; i++) {
          pairs.add(Pair.of(keys.get(i), cycle.get(i)));
        }
        return pairs;
      }
    }
    return Lists.newArrayList();
  }

  private static Pair<List<Integer>, List<Long>> makeCycle(final List<Integer> lastKeys, final List<Long> lastCycle) {
    if (lastCycle.size() == size && canJoin(lastCycle.get(size - 1), lastCycle.get(0))) {
      return Pair.of(lastKeys, lastCycle);
    }
    //System.out.println("Testing " + lastCycle);
    long lastP = lastCycle.get(lastCycle.size() - 1);
    for (int s : Sets.difference(table.keySet(), Sets.newTreeSet(lastKeys))) {
      for (long p : table.get(s)) {
        if (p % 100 / 10 == 0) continue;
        if (canJoin(lastP, p)) {
          List<Integer> testKeys = Lists.newArrayList(lastKeys);
          testKeys.add(s);
          List<Long> testCycle = Lists.newArrayList(lastCycle);
          testCycle.add(p);
          Pair<List<Integer>, List<Long>> pair = makeCycle(testKeys, testCycle);
          if (!pair.getLeft().isEmpty()) return pair;
        }
      }
    }
    return Pair.<List<Integer>, List<Long>>of(Lists.<Integer>newArrayList(), Lists.<Long>newArrayList());
  }

  public static void main(String[] args) {
    size = args.length > 0 ? Integer.parseInt(args[0]) : 6;

    populateMap();

    long sum = 0;
    List<Pair<Integer, Long>> pairs = makeCycle();
    for (int i = 0; i < size; i++) {
      Pair<Integer, Long> pair = pairs.get(i);
      int s = pair.getLeft();
      long p = pair.getRight(), n = invP(s, p);
      sum += p;
      System.out.print("P(" + s + "," + n + ") = " + p + ", ");
    }
    System.out.println();

    System.out.println("The sum of the only ordered set of " + size
        + " cyclic 4-digit numbers for which each polygonal type: "
        + " triangle, square, pentagonal, hexagonal, heptagonal, and octagonal,");
    System.out.println("is represented by a different number in the set is " + sum);
  }
}
