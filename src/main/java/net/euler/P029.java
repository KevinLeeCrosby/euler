package net.euler;

import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import org.apache.commons.math3.util.Pair;

import java.util.*;

/**
 * Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
 * <p/>
 * 2^2=4, 2^3=8, 2^4=16, 2^5=32
 * 3^2=9, 3^3=27, 3^4=81, 3^5=243
 * 4^2=16, 4^3=64, 4^4=256, 4^5=1024
 * 5^2=25, 5^3=125, 5^4=625, 5^5=3125
 * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
 * <p/>
 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 * <p/>
 * How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 */
public class P029 {
  private static final Primes P = Primes.getInstance();

  private static Long gcd(final long a, final long b) {
    return b == 0 ? a : gcd(b, a % b);
  }

  private static Long lcm(final long a, final long b) {
    return a * b / gcd(a, b);
  }

  private static boolean isPerfectPower(final long number) {
    return baseDegree(number).getSecond() > 1;
  }

  private static Pair<Long, Long> baseDegree(final long power) {
    List<Long> factors = P.factor(power);
    long base = 1;
    long degree = 0;
    for (long factor : Sets.newHashSet(factors)) {
      int exponent = Collections.frequency(factors, factor);
      degree = gcd(degree, exponent);
      base *= factor;
    }
    return Pair.create(base, degree);
  }

  private static int log2(int bits) { // discrete log2
    int log = 0;
    if ((bits & 0xffff0000) != 0) {
      bits >>>= 16;
      log = 16;
    }
    if (bits >= 256) {
      bits >>>= 8;
      log += 8;
    }
    if (bits >= 16) {
      bits >>>= 4;
      log += 4;
    }
    if (bits >= 4) {
      bits >>>= 2;
      log += 2;
    }
    return log + (bits >>> 1);
  }

  private static Map<Long, Integer> countDuplicatesPerDegree(int max) {
    Map<Long, Integer> duplicates = Maps.newHashMap();
    int maxDegree = log2(max);
    for (long d = 2; d <= maxDegree; d++) {
      Set<Integer> overlap = new HashSet<>(max / 2); // set initial capacity for speed
      for (long k = 1; k <= d - 1; k++) {
        Long increment = lcm(k, d) / d;
        for (int j = 2 * increment.intValue(); j <= k * max / d; j += increment) {
          overlap.add(j);
        }
      }
      duplicates.put(d, overlap.size());
    }
    return duplicates;
  }

  public static void main(String[] args) {
    int max; // keep max as int because of discrete log
    if (args.length > 0) {
      max = Integer.parseInt(args[0]);
    } else {
      max = 100; // works up to at least 10000000 => 99982936419184 (https://projecteuler.net/thread=29;page=5)
    }

    long range = max - 1;
    long count = 0L;  // count = range * range gives overflow if range is int
    long duplicates = 0L;

    System.out.println("Counting duplicates per degree ...");
    Map<Long, Integer> duplicatesPerDegree = countDuplicatesPerDegree(max);

    for (long a = 2; a <= max; a++) {
      count += range;
      if (!P.isPrime(a) && isPerfectPower(a)) {
        Pair<Long, Long> baseDegree = baseDegree(a);
        long base = baseDegree.getFirst();
        long exponent = baseDegree.getSecond();
        int dpd = duplicatesPerDegree.get(exponent);
        count -= dpd;
        duplicates += dpd;
        System.out.println("Found perfect power " + a + " = " + base + "^" + exponent + ", with " + dpd + " duplicates.");
      }
    }
    System.out.println("Found " + duplicates + " total duplicates.");
    System.out.println("There are " + count + " distinct terms in the sequence generated by a^b for 2 ≤ a ≤ "
        + max + " and 2 ≤ b ≤ " + max + ".");
  }
}
